# SPDX-License-Identifier: GPL-2.0-or-later
bl_info = {
    "name": "UIX - Quick Snap Bar",
    "author": "Generated by ChatGPT",
    "version": (0, 1, 0),
    "blender": (3, 0, 0),
    "location": "3D Viewport > Header (right side)",
    "description": "Adds a compact Snap quick bar to the right side of the 3D View header.",
    "category": "Interface",
}

import bpy
from bpy.props import BoolProperty, StringProperty


ADDON_KEY = __package__ if __package__ else __name__


# -------------------------
# Helpers
# -------------------------
ICON_BY_ELEMENT = {
    "INCREMENT": "SNAP_INCREMENT",
    "GRID": "SNAP_GRID",
    "VERTEX": "SNAP_VERTEX",
    "EDGE": "SNAP_EDGE",
    "FACE": "SNAP_FACE",
    "VOLUME": "SNAP_VOLUME",
    "EDGE_MIDPOINT": "SNAP_MIDPOINT",
    "EDGE_PERPENDICULAR": "SNAP_PERPENDICULAR",
}


def _prefs(context):
    addon = context.preferences.addons.get(ADDON_KEY)
    return addon.preferences if addon else None


def _has_prop(obj, prop_name: str) -> bool:
    return hasattr(obj, prop_name)


def _draw_prop(layout, obj, prop_name: str, **kwargs):
    if _has_prop(obj, prop_name):
        layout.prop(obj, prop_name, **kwargs)


def _snap_elements_supported(ts) -> set[str]:
    """Return supported enum keys for ToolSettings.snap_elements, if present."""
    if not _has_prop(ts, "snap_elements"):
        return set()
    try:
        items = ts.bl_rna.properties["snap_elements"].enum_items
        return set([it.identifier for it in items])
    except Exception:
        return set()


def _get_snap_elements(ts) -> set[str]:
    if _has_prop(ts, "snap_elements"):
        try:
            return set(ts.snap_elements)
        except TypeError:
            # Some builds may return an enum string, not a set
            val = ts.snap_elements
            return {val} if isinstance(val, str) else set()
    # Legacy (very old Blender): singular snap_element
    if _has_prop(ts, "snap_element"):
        val = getattr(ts, "snap_element", "")
        return {val} if val else set()
    return set()


def _set_snap_elements(ts, elements: set[str]):
    if _has_prop(ts, "snap_elements"):
        ts.snap_elements = elements
        return
    if _has_prop(ts, "snap_element"):
        # Fallback: pick one element (not a true set in old versions)
        ts.snap_element = next(iter(elements), "INCREMENT")


def _icon(elem_id: str, fallback: str = "SNAP_ON") -> str:
    """Return a Blender icon identifier (best-effort)."""
    # Blender will error if an icon id is invalid; keep the mapping conservative.
    return elem_id or fallback


# -------------------------
# Operators
# -------------------------
class UIX_OT_toggle_snap_element(bpy.types.Operator):
    """Toggle a snap element in Tool Settings"""
    bl_idname = "uix.toggle_snap_element"
    bl_label = "Toggle Snap Element"
    bl_options = {'REGISTER', 'UNDO'}

    element: StringProperty(name="Element", default="INCREMENT")

    @classmethod
    def poll(cls, context):
        return context.scene is not None and hasattr(context.scene, "tool_settings")

    def execute(self, context):
        ts = context.scene.tool_settings
        supported = _snap_elements_supported(ts)
        if supported and self.element not in supported:
            self.report({'WARNING'}, f"Snap element '{self.element}' not supported in this Blender build.")
            return {'CANCELLED'}

        elems = _get_snap_elements(ts)
        if self.element in elems:
            elems.remove(self.element)
        else:
            elems.add(self.element)

        # Ensure at least one element remains selected (Blender UX expectation)
        if not elems:
            elems.add("INCREMENT") if (not supported or "INCREMENT" in supported) else elems.add(next(iter(supported)))

        _set_snap_elements(ts, elems)
        return {'FINISHED'}


class UIX_OT_set_snap_base(bpy.types.Operator):
    """Set snap base quickly"""
    bl_idname = "uix.set_snap_base"
    bl_label = "Set Snap Base"
    bl_options = {'REGISTER', 'UNDO'}

    base: StringProperty(name="Base", default="CLOSEST")

    @classmethod
    def poll(cls, context):
        ts = getattr(getattr(context, "scene", None), "tool_settings", None)
        return ts is not None and hasattr(ts, "snap_base")

    def execute(self, context):
        ts = context.scene.tool_settings
        try:
            ts.snap_base = self.base
        except Exception as e:
            self.report({'WARNING'}, f"Could not set snap base: {e}")
            return {'CANCELLED'}
        return {'FINISHED'}


# -------------------------
# Popover Panel (optional)
# -------------------------
class UIX_PT_snap_popover(bpy.types.Panel):
    bl_label = "Quick Snap"
    bl_idname = "UIX_PT_snap_popover"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'HEADER'
    bl_ui_units_x = 14

    def draw(self, context):
        layout = self.layout
        ts = context.scene.tool_settings

        layout.use_property_split = True
        layout.use_property_decorate = False

        col = layout.column(align=True)
        _draw_prop(col, ts, "use_snap", text="Snap")

        box = layout.box()
        box.label(text="Snap Base")
        if _has_prop(ts, "snap_base"):
            box.prop(ts, "snap_base", expand=True)

        box = layout.box()
        box.label(text="Snap Target (Elements)")
        if _has_prop(ts, "snap_elements"):
            box.prop(ts, "snap_elements", expand=True)
        elif _has_prop(ts, "snap_element"):
            box.prop(ts, "snap_element", text="Element")

        box = layout.box()
        box.label(text="Options")
        _draw_prop(box, ts, "use_snap_grid_absolute", text="Absolute Increment")
        _draw_prop(box, ts, "use_snap_align_rotation", text="Align Rotation to Target")
        _draw_prop(box, ts, "use_snap_backface_culling", text="Backface Culling")

        box = layout.box()
        box.label(text="Affect")
        row = box.row(align=True)
        _draw_prop(row, ts, "use_snap_translate", text="Move")
        _draw_prop(row, ts, "use_snap_rotate", text="Rotate")
        _draw_prop(row, ts, "use_snap_scale", text="Scale")

        # Rotation increment (name varies across versions)
        for prop in ("snap_angle_increment", "snap_rotation_increment", "snap_angle_increment_3d"):
            if _has_prop(ts, prop):
                layout.separator()
                layout.prop(ts, prop, text="Rotation Increment")
                break


# -------------------------
# Addon Preferences
# -------------------------
class UIX_Preferences(bpy.types.AddonPreferences):
    bl_idname = ADDON_KEY

    show_in_view3d_header: BoolProperty(
        name="Show in 3D View Header",
        default=True,
    )
    show_snap_base_buttons: BoolProperty(
        name="Show Snap Base Buttons",
        default=True,
    )
    show_popover: BoolProperty(
        name="Show Popover (full options)",
        default=True,
    )

    # Quick element buttons (common)
    elem_increment: BoolProperty(name="Increment", default=True)
    elem_grid: BoolProperty(name="Grid", default=False)
    elem_vertex: BoolProperty(name="Vertex", default=True)
    elem_edge: BoolProperty(name="Edge", default=True)
    elem_face: BoolProperty(name="Face", default=True)
    elem_volume: BoolProperty(name="Volume", default=False)
    elem_edge_midpoint: BoolProperty(name="Edge Center", default=False)
    elem_edge_perpendicular: BoolProperty(name="Edge Perpendicular", default=False)

    def draw(self, context):
        layout = self.layout
        layout.label(text="Viewport Header")
        layout.prop(self, "show_in_view3d_header")
        layout.prop(self, "show_snap_base_buttons")
        layout.prop(self, "show_popover")

        layout.separator()
        layout.label(text="Quick Snap Element Buttons")
        grid = layout.grid_flow(columns=2, even_columns=True, even_rows=False, align=True)
        grid.prop(self, "elem_increment")
        grid.prop(self, "elem_grid")
        grid.prop(self, "elem_vertex")
        grid.prop(self, "elem_edge")
        grid.prop(self, "elem_face")
        grid.prop(self, "elem_volume")
        grid.prop(self, "elem_edge_midpoint")
        grid.prop(self, "elem_edge_perpendicular")


# -------------------------
# Header draw callback
# -------------------------
def _draw_snap_quickbar(self, context):
    prefs = _prefs(context)
    if not prefs or not prefs.show_in_view3d_header:
        return

    scene = context.scene
    if scene is None:
        return
    ts = getattr(scene, "tool_settings", None)
    if ts is None:
        return

    layout = self.layout
    row = layout.row(align=True)

    # Snap toggle
    icon = "SNAP_ON" if getattr(ts, "use_snap", False) else "SNAP_OFF"
    _draw_prop(row, ts, "use_snap", text="", icon=_icon(icon))

    # Snap base buttons (Closest / Center / Median / Active)
    if prefs.show_snap_base_buttons and _has_prop(ts, "snap_base"):
        bases = [
            ("CLOSEST", "C", "Closest"),
            ("CENTER", "Ctr", "Center"),
            ("MEDIAN", "Med", "Median"),
            ("ACTIVE", "Act", "Active"),
        ]
        base_row = row.row(align=True)
        base_row.scale_x = 0.85
        for base_id, short, _label in bases:
            op = base_row.operator("uix.set_snap_base", text=short, depress=(ts.snap_base == base_id))
            op.base = base_id

    # Quick element toggles
    supported = _snap_elements_supported(ts)
    current = _get_snap_elements(ts)

    def add_elem_button(elem_id: str):
        if supported and elem_id not in supported:
            return
        icon_id = _icon(ICON_BY_ELEMENT.get(elem_id, "SNAP_ON"))
        op = row.operator(
            "uix.toggle_snap_element",
            text="",
            icon=icon_id,
            depress=(elem_id in current),
        )
        op.element = elem_id

    # Order matters: keep common ones tight
    if prefs.elem_increment:
        add_elem_button("INCREMENT")
    if prefs.elem_grid:
        add_elem_button("GRID")
    if prefs.elem_vertex:
        add_elem_button("VERTEX")
    if prefs.elem_edge:
        add_elem_button("EDGE")
    if prefs.elem_face:
        add_elem_button("FACE")
    if prefs.elem_volume:
        add_elem_button("VOLUME")
    if prefs.elem_edge_midpoint:
        add_elem_button("EDGE_MIDPOINT")
    if prefs.elem_edge_perpendicular:
        add_elem_button("EDGE_PERPENDICULAR")

    # Optional: popover for the full set (keeps header compact)
    if prefs.show_popover:
        row.popover(panel=UIX_PT_snap_popover.bl_idname, text="", icon='DOWNARROW_HLT')


# -------------------------
# Registration
# -------------------------
CLASSES = (
    UIX_OT_toggle_snap_element,
    UIX_OT_set_snap_base,
    UIX_PT_snap_popover,
    UIX_Preferences,
)


def register():
    for cls in CLASSES:
        bpy.utils.register_class(cls)

    bpy.types.VIEW3D_HT_header.append(_draw_snap_quickbar)


def unregister():
    bpy.types.VIEW3D_HT_header.remove(_draw_snap_quickbar)

    for cls in reversed(CLASSES):
        bpy.utils.unregister_class(cls)


if __name__ == "__main__":
    register()
